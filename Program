#pragma config(Sensor, port3,  Gyro,           sensorVexIQ_Gyro)
#pragma config(Motor,  motor5,          LMotor,        tmotorVexIQ, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motor6,          RMotor,        tmotorVexIQ, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float g_rotation = 0.0;

void resetChassisEncoder()
{
	resetMotorEncoder(LMotor);
	resetMotorEncoder(RMotor);
}

void setChassisSpeed(int leftSpeed, int rightSpeed)
{
	setMotorSpeed(LMotor, leftSpeed);
	setMotorSpeed(RMotor, rightSpeed);
}

float getChassisEncoder()
{
	return ((getMotorEncoder(LMotor)) + (getMotorEncoder(RMotor)/2));
}
//_____________________________________________________________________________________________________________________
/**
* @brief Move chassis based on steering value
*        steerig 0, move forward
*        +/- 0-50, smooth turn (2 wheel turn)
*        +/- 50, pivot turn
*        +/- 50-100, one positve, one negative 2 wheel turn (rarely used)
*        +/- 100, on spot turn
*        +, turning left
*        -, turning right
*
* @param steering Steering direction of the robot
* @param speed Moving speed of the robot
*/
void moveSteering(float steering, int speed)
{
	int leftSpeed;
	int rightSpeed;

	if (steering > 0) // turn left
	{
		leftSpeed = (steering * (-2) + 100) * speed / 100;
		rightSpeed = speed;
	}

	if(steering < 0) // turn right
	{
		leftSpeed = speed;
		rightSpeed = (steering * 2 + 100) * speed / 100;
	}

	if(steering == 0){ // go straight
		leftSpeed = speed;
		rightSpeed = speed;
}

	setChassisSpeed(leftSpeed, rightSpeed);
}
//_____________________________________________________________________________________________________________________
/**
* @brief Turn the robot to target rotation
*
* @param heading Target rotation of the robot turning
* @param steering Steering value to be passed to moveSteering (see moveSteering for detailed explanation)
* @param speed Moving speed of the robot
* @param momentum Momentum value to stop the robot before it reaches target rotation
*/
void turn(float heading, int steering, int speed, float decelRate, float decelZone)
{
 	float minSpeed = 10;
	float currentSpeed = speed;
	resetGyro(Gyro);
	while (abs(getGyroDegreesFloat(Gyro)) < abs(heading)){
		if(abs(getGyroDegreesFloat(Gyro)) > abs(heading) - abs(decelZone)){ //decel
			currentSpeed = currentSpeed * (1 - decelRate);
			if(abs(currentSpeed) < abs(minSpeed)){
				currentSpeed = abs(minSpeed);
			}
		}
		moveSteering(steering, currentSpeed);
	}
}
//_____________________________________________________________________________________________________________________
float integral = 0.0;
float previousError = 0.0;

float PIDController(float error, float kp, float ki, float kd, float dt)
{
    integral = integral + error * dt;
    float derivative = (error - previousError) / dt;
    float output = kp * error + ki * integral + kd * derivative;
    previousError = error;
    return output;
}

void goStraightPID(float heading, float speed, float distance, float kp, float ki, float kd, float accelRate, float decelRate, float decelZone)
{
	float error;
	float output;
	int dt = 20;
	integral = 0.0;
	previousError = 0.0;
	int minSpeed = 10;
	float currentSpeed = minSpeed;

	// reset all motor encoders
	resetChassisEncoder();
	resetGyro(Gyro);
	while (abs(getChassisEncoder()) < abs(distance))
	{
		// P control of the robot direction
		error = heading - getGyroDegreesFloat(Gyro);
		output = PIDController(error, kp, ki, kd, dt);
		moveSteering(output, currentSpeed);
		if(abs(getChassisEncoder()) > abs(distance) - abs(decelZone)){ //decel
			currentSpeed = currentSpeed * (1 - decelRate);
			if(abs(currentSpeed) < abs(minSpeed)){
				currentSpeed = abs(minSpeed);
			}
		}
		else if(abs(currentSpeed) < abs(speed)){//accel
			currentSpeed = currentSpeed * (1 + accelRate);
			if(abs(currentSpeed) > abs(speed)){
				currentSpeed = speed;
			}
		}
		

		wait1Msec(dt);
	}
	setChassisSpeed(0,0);
}

/*
previous_error := 0
integral := 0

loop:
    error := setpoint - measured_value
    proportional := error;
    integral := integral + error ï¿½ dt
    derivative := (error - previous_error) / dt
    output := Kp ï¿½ proportional + Ki ï¿½ integral + Kd ï¿½ derivative
    previous_error := error
    wait(dt)
    goto loop
*/
//_____________________________________________________________________________________________________________________
task main()
{
	resetGyro(Gyro);
	g_rotation = 0.0;
	goStraightPID(0, 90, 1500, 1, 0,0, 0.1, 0.1, 250);
	turn(90, 100, 70, 0.1, 70);

	// write a square test, have the robot drive a square to see if it always return to the same spot and direction
	writeDebugStream("%f", g_rotation); // what's value of g_rotation at this point? is it 1?
}
